<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Syntax - Owl Book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-0fcf3e67.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-42a9021b.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-8d1946d2.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Owl Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="syntax"><a class="header" href="#syntax">Syntax</a></h1>
<p>Below serves as a reference to the syntax of Owl.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Owl is composed of <em>specification-level</em> objects, such as <a href="#names">names</a> and <a href="#types">(data) types</a>, and <a href="#expressions">expressions</a>, which are meant to be run.</p>
<p>The specification-specific syntax of Owl is stratified in a number of layers:</p>
<ul>
<li><a href="#names">names</a>, which are type-level cryptographic keys;</li>
<li><a href="#labels">labels</a>, which drive Owl’s information-flow typing rules;</li>
<li><a href="#types">types</a>, which specify the types of data; and</li>
<li><a href="#name-types">name types</a>, which can be thought of as specifications for names (as types are specifications for data).</li>
</ul>
<h2 id="names"><a class="header" href="#names">Names</a></h2>
<p>Names in Owl are cryptographic keys which are reflected to the type level. Names can either be <em>base names</em>, given by an identifier (e.g., <code>n</code>), or <em>derived</em> names of the form <code>KDF&lt;...&gt;(...)</code> (explained below).</p>
<p>Base names are created by a <em>name declaration</em>:</p>
<pre><code class="language-owl">name k : nt @ loc
</code></pre>
<p>where <code>nt</code> is a <a href="#name-types">name type</a> and <code>loc</code> is a <a href="#localities">locality</a>.
In an expression, you can obtain the value of <code>k</code> by calling <code>get(k)</code> (this will not work if the code is running at a different locality than the name, however).
The type of <code>get(k)</code> is <code>Name(k)</code> (explained <a href="#types">below</a>).</p>
<p>Name declarations (among other things) can be <em>indexed</em>, as so:</p>
<pre><code class="language-owl">name k&lt;i, j @ k&gt; : enckey t @ loc&lt;k&gt;
</code></pre>
<p>This creates a name <code>k</code> indexed by two <em>session IDs</em>, <code>i</code> and <code>j</code>, and a <em>party ID</em> <code>k</code>. All indices may be used in the type <code>t</code>, but only party IDs may be used in the associated locality.</p>
<h3 id="kdf-names"><a class="header" href="#kdf-names">KDF Names</a></h3>
<p>Aside from assuming names as input to the protocol, names can also be <em>derived</em> via a call to a key derivation function. Owl currently supports HKDF.
A secure output of HKDF results in value of type <code>Name(KDF&lt;nk_1 || ... || nk_n; i; nt&gt;(a, b, c))</code>.
Details about the KDF operation and <code>KDF</code> name are specified <a href="./hkdf.html">here</a>.</p>
<h3 id="name-types"><a class="header" href="#name-types">Name Types</a></h3>
<p>Each name in Owl has a <em>name type</em>, which is intuitively the cryptographic permissions that the corresponding key is allowed to be used for.
Each <a href="./crypto.html">cryptographic operation</a> has a corresponding name type.</p>
<h3 id="grammar"><a class="header" href="#grammar">Grammar</a></h3>
<p>Names:</p>
<pre><code>N ::= n // Base name
   |  n&lt;i@j&gt; // Indexed name
   |  KDF&lt;nk_1 || ... || nk_n; i; nt&gt;(a, b, c) // KDF Name
</code></pre>
<p>Name Types:</p>
<p>Below is an (incomplete) list of some name types supported by Owl:</p>
<ul>
<li><code>DH</code>, for <a href="./hkdf.html">Diffie-Hellman</a>;</li>
<li><code>nonce</code>, for <a href="./nonce.html">random, unstructured secrets</a></li>
<li><code>nonce |LC|</code>, for <a href="./nonce.html">random, unstructured secrets</a> where <code>|LC|</code> is a <a href="#length-constants">length constant</a>;</li>
<li><code>sigkey T</code>, for <a href="./signatures.html">signing keys</a>;</li>
<li><code>enckey T</code>, for <a href="./aenc.html">encryption keys</a>;</li>
<li><code>pkekey T</code>, for <a href="./pke.html">public encryption keys</a>;</li>
<li><code>mackey T</code>, for <a href="./mac.html">MAC keys</a>;</li>
<li><code>NT&lt;..&gt;(x, y, .., z)</code> for name type abbreviations. Here, <code>&lt;..&gt;</code> contains (optional) <a href="#indices">index</a> parameters; while <code>x, y, ..., z</code> are arguments given as <a href="#atomic-expressions">atomic expressions</a>;</li>
<li><code>st_aead ...</code>, for stateful AEAD <a href="./aenc.html">details here</a>;</li>
<li><code>kdf ...</code> and <code>dualkdf ...</code> for KDF keys <a href="./hkdf.html">details here</a>.</li>
</ul>
<h2 id="labels"><a class="header" href="#labels">Labels</a></h2>
<p>Labels form the basis of Owl’s information flow analysis.
The two most important labels are <em>name labels</em> and the <em>adversary labels</em>.
If <code>N</code> is a <a href="#names">name</a>, then <code>[N]</code> is the label associated to <code>N</code>. (For example, <code>get(N)</code> has label <code>[N]</code>). The adversary label, <code>adv</code>, is the label for public data.
Owl labels form a <em>semilattice</em>, meaning that there is a binary operation <code>/\</code> between labels that constructs the least upper bound of the two labels.</p>
<p>Here is an example piece of code that exercises labels:</p>
<pre><code class="language-owl">locality alice
name n : nonce @ alice
name m : nonce @ alice

def foo() @ alice : Unit = 
    input i in 
    let j : Data&lt;adv&gt; = i in 
    let x : Data&lt;[n]&gt; = get(n) in 
    let y : Data&lt;[m]&gt; = get(m) in 
    let z : Data&lt;[n] /\ [m]&gt; = x ++ y in 
    ()
</code></pre>
<p>After defining two names <code>n</code> and <code>m</code>, we take an input <code>i</code> from the network inside of <code>foo</code>.
We then assign <code>i</code> to <code>j</code>, and give it the type <code>Data&lt;adv&gt;</code>; this type represents “data labelled at <code>adv</code>”. Hence, <code>x</code> has type <code>Data&lt;[n]&gt;</code>, <code>y</code> has type <code>Data&lt;[m]&gt;</code>, and <code>x ++ y</code> has type <code>Data&lt;[n] /\ [m]&gt;</code> (since we are combining <code>x</code> and <code>y</code> through concatenation).</p>
<h3 id="indexed-joins-of-labels"><a class="header" href="#indexed-joins-of-labels">Indexed joins of labels</a></h3>
<p>In more complicated code, one might have an indexed name <code>n&lt;i&gt;</code> and need to represent the label for data that depends on <em>some</em> <code>n&lt;i&gt;</code>, but we don’t know which one. In this case, one can use an <em>indexed join</em>:</p>
<pre><code class="language-owl">locality alice
name n&lt;i&gt; : nonce @ alice

def foo&lt;i&gt;() @ alice : Unit = 
    input i in 

    let x : Data&lt;[n&lt;i&gt;]&gt; = get(n&lt;i&gt;) in 
    let y : Data&lt;/\_k [n&lt;k&gt;]&gt; = x in 
    ()
</code></pre>
<p>Here, the label <code>/\_k [n&lt;k&gt;]</code> is the join over all labels of the form <code>[n&lt;k&gt;]</code>, for all <code>k</code>.</p>
<h3 id="information-flow-ordering"><a class="header" href="#information-flow-ordering">Information Flow Ordering</a></h3>
<p>Given two labels <code>L1</code> and <code>L2</code>, the <a href="#propositions">proposition</a> <code>L1 &lt;= L2</code> states that label <code>L1</code> flows to <code>L2</code>. The bottom of the information flow lattice is <code>static</code> (so <code>static</code> flows to everything).</p>
<p>We use the information flow order to define corruption. We say that the name <code>n</code> is <em>corrupt</em> if <code>[n] &lt;= adv</code>, and is <em>secret</em> otherwise (which we write as <code>[n] !&lt;= adv</code>).</p>
<p>A central part of Owl is that the information flow ordering is influenced by crytographic primitives. If <code>n</code> is an encryption key for data labeled at <code>L</code>, then we get that <code>L &lt;= [n]</code>. More details are given when discussing <a href="./crypto.html">cryptographic operations</a>.</p>
<h3 id="grammar-1"><a class="header" href="#grammar-1">Grammar</a></h3>
<pre><code>L ::= [N]
    | static
    | adv
    | L /\ L
    | /\_i L   // Join over index
</code></pre>
<p>In addition to the above, there are a few labels internal to the implementation of Owl — <code>top</code> and <code>ghost</code> — but these can be safely ignored in user code.</p>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<p>Cryptographic security in Owl is expressed via types. Owl types can be thought of as having two components: a <em>secrecy</em> component, expressed using information-flow labels; and an <em>integrity</em> component, expressed using refinement and singleton types. As is common in information-flow type systems, Owl types support <em>subtyping</em>, which states when data in one type can be considered to have another type.</p>
<h3 id="basic-types"><a class="header" href="#basic-types">Basic Types</a></h3>
<p>Logically, <em>all</em> data in Owl are bytestrings — even structs and enums, which should be thought of as holding their parsed representations (where structs have their field concatenated, and enums are implicitly tagged unions).</p>
<h4 id="data-types"><a class="header" href="#data-types">Data Types</a></h4>
<p>Suppose <code>L</code> and <code>L'</code> are <a href="#labels">labels</a>, and <code>a</code> is an <a href="#atomic-expressions">atomic expression</a>. Then, the types <code>Data&lt;L&gt;</code>, <code>Data&lt;L, |L|&gt;</code> and <code>Data&lt;L&gt; |a|</code> all represent arbitrary data (i.e., bytestrings) with various secrecy and integrity information.</p>
<ul>
<li>The type <code>Data&lt;L&gt;</code> represents arbitrary data with secrecy <code>L</code>.</li>
<li>The type <code>Data&lt;L, |L'|&gt;</code> represents arbitrary data with secrecy <code>L</code>, where the <em>length</em> of that data has label <code>L'</code>. This is mostly used in the form <code>Data&lt;L, |adv|&gt;</code>, which represents public-length data.</li>
<li>The type <code>Data&lt;L&gt; |a|</code> represents data with secrecy <code>L</code>, where the length of that data is statically known to have length equal to the value of <code>a</code>. The most common use case here is where <code>a</code> is a constant: e.g., <code>Data&lt;adv&gt; |32|</code>, for 32-byte length data, or <code>Data&lt;adv&gt; | |nonce| |</code>, where <code>|nonce|</code> is the constant for the length of a <code>nonce</code> name.</li>
</ul>
<p>The above types use the information-flow lattice to define the subtyping order. For example, <code>Data&lt;L&gt;</code> is a subtype of <code>Data&lt;L'&gt;</code> whenever `L &lt;= L’.</p>
<p>A unifying principle of Owl is that <em>all data are bytestrings</em>. Thus, the (non-ghost component</p>
<h4 id="unit-and-lemma"><a class="header" href="#unit-and-lemma">Unit and Lemma</a></h4>
<p>The type <code>Unit</code> (with distinguished element <code>()</code>) behaves as it does in other languages. Importantly, however, the <code>Unit</code> type can be <a href="#refinement-types"><em>refined</em></a>, just as any other type can be. Thus, we can say things like:</p>
<pre><code class="language-owl">locality alice

def foo(x : Data&lt;adv&gt;, pf : (_:Unit{x != 0x1234})) @ alice : Unit = 
    ()

</code></pre>
<p>Here, we refine the <code>Unit</code> type with a proof that <code>x</code> is not equal to <code>0x1234</code>. (We could have refined <code>x</code> as well, but it is often convenient to detatch the proof from the data). In this special case, we can also type:</p>
<pre><code class="language-owl">def foo(x : Data&lt;adv&gt;, pf : Lemma{x != 0x1234}) @ alice : Unit = 
    ()
</code></pre>
<p>Here, <code>Lemma{P}</code> is sugar for <code>_:Unit{P}</code>.</p>
<h4 id="bool"><a class="header" href="#bool">Bool</a></h4>
<p>If <code>L</code> is an information flow label, then <code>Bool&lt;L&gt;</code> is the type of booleans with secrecy level <code>L</code>. Just like with <code>Data</code>, <code>Bool</code> respects subtyping with respect to the level <code>L</code>.</p>
<h3 id="refinement-types"><a class="header" href="#refinement-types">Refinement Types</a></h3>
<p>To express arbitrary integrity properties, Owl supports <em>refinement types</em>. If <code>T</code> is a type, and <code>P</code> is a <a href="#propositions">proposition</a> that mentions <code>x : T</code>, then <code>x:T{P}</code> is a type. Refinement types in Owl behave similarly to <a href="https://fstar-lang.org/tutorial/">F*</a>, and are checked using an SMT solver.</p>
<h3 id="structs-enums-and-option-types"><a class="header" href="#structs-enums-and-option-types">Structs, Enums, and Option Types</a></h3>
<p>Owl supports byte-precise data types via structs and enums.</p>
<h4 id="structs"><a class="header" href="#structs">Structs</a></h4>
<p>Below is a simple struct, used in our formalization of WireGuard:</p>
<pre><code class="language-owl">// And the transport layer message
struct transp {
      _transp_tag : Const(0x04000000)
    , _transp_receiver : Data&lt;adv&gt; |4|
    , _transp_counter  : Data&lt;adv&gt; | |counter| | 
    , _transp_packet   : Data&lt;adv&gt; 
}
</code></pre>
<p>A struct is defined by a number of fields, specified by an identifier and a type.
The naming scheme we use here for each field (<code>_struct_field</code>) is not necessary, but useful for namespacing.
The first field here has a <a href="#const">const</a> type, while the next two are <a href="#data-types">data types refined with a length</a>, and the last is simply public data. While the above struct is used for a network format, Owl structs can also be used for internal data structures for protocols, such as a record of the most recently derived secret keys.</p>
<h5 id="dependent-structs"><a class="header" href="#dependent-structs">Dependent Structs</a></h5>
<p>The types in structs can depend on previous values:</p>
<pre><code class="language-owl">locality alice

struct ne_pair {
    x : Data&lt;adv&gt; | 2 |, 
    y : (z:Data&lt;adv&gt; | 2 | {z != x}) 
}

def foo() @ alice : Unit = 
    let v : ne_pair = ne_pair(0x1234, 0x5678) in  // OK 
    let v2 : ne_pair = ne_pair(0x1234, 0x1234) in  // Fails to type check
    ()
</code></pre>
<h5 id="invalid-structs-and-other-data"><a class="header" href="#invalid-structs-and-other-data">Invalid Structs (and other data)</a></h5>
<p>Since <a href="#basic-types">all data in Owl are byte strings</a>, building a struct may have meaning even if the corresponding type refinements in the struct do not hold. We model this through the following strategy: <em>applying invalid arguments to a function results in the information-flow approximation to their type</em>. In the case of structs, this is justified since a constructor for a struct in Owl’s semantics is simply a function which concatenates its arguments together.</p>
<p>We can see this here:</p>
<pre><code class="language-owl">
// tst.owl

locality alice

name n : nonce @ alice

struct ne_pair {
    x : Data&lt;adv&gt; | 2 |, 
    y : (z:Data&lt;adv&gt; | 2 | {z != x}) 
}

def foo() @ alice : Unit = 
    let v : ne_pair = ne_pair(0x1234, 0x5678) in 
    let v2 = ne_pair(get(n), 0x) in  // 0x = empty byte string
    debug printTyOf(v); 
    debug printTyOf(v2); 
    ()
</code></pre>
<p>When we run the above code with <code>cabal run owl -- tst.owl --log-typecheck</code>, we get the following output:</p>
<pre><code>  Type for v: ne_pair
  Type for v2: .res:(Data&lt;[n]&gt;){.res == ne_pair(get(n), 0x)}
</code></pre>
<p>Here, <code>v</code> is a valid <code>ne_pair</code> (because all relevant subtyping queries succeeded), while <code>v2</code> is not. In this case, Owl simply re-interprets <code>ne_pair</code> as the concatenation function.</p>
<p>In the type refinement for <code>v2</code>, we see that Owl remembers that the value of <code>v2</code> is equal to <code>ne_pair(get(n), 0x)</code>. (In type refinements, <code>ne_pair</code> is interpreted as a pure function on byte strings.)</p>
<p>(Details for the <code>debug</code> expression are given <a href="#debug-expressions">here</a>.)</p>
<h5 id="parsing"><a class="header" href="#parsing">Parsing</a></h5>
<p>Since a value of type <code>ne_pair</code> is regarded as a specially formatted byte string, we do not destruct it via <code>.</code> syntax, as one does in C. Instead, we have <em>parse</em> statements:</p>
<pre><code class="language-owl">locality alice

name n : nonce @ alice

struct ne_pair {
    x : Data&lt;adv&gt; | 2 |, 
    y : (z:Data&lt;adv&gt; | 2 | {z != x}) 
}

def foo() @ alice : Unit = 
    let v : ne_pair = ne_pair(0x1234, 0x5678) in 
    parse v as ne_pair(a, b) in 
    ()
</code></pre>
<p>More details are given <a href="#parsing-structs">below</a>.</p>
<h3 id="singleton-types"><a class="header" href="#singleton-types">Singleton Types</a></h3>
<p>A <em>singleton type</em> is a type with exactly one inhabitant. Other than <a href="#unit-and-lemma">unit</a>, Owl uses singleton types pervasively to reason about type refinements.</p>
<h4 id="const"><a class="header" href="#const">Const</a></h4>
<p>Given a fixed byte sequence, such as <code>0x1234</code>, <code>Const(0x1234)</code> is the singleton type for exactly that byte sequence. Such a type is useful to specify tags in TLV formats, for example. Since <code>0x1234</code> is a hardcoded constant, this type is a subtype of <code>Data&lt;static&gt;</code>.</p>
<h4 id="name"><a class="header" href="#name">Name</a></h4>
<p>A <em>name type</em> is a specification for a name, and is part of a name declaration. For example:</p>
<pre><code class="language-owl">locality alice
name n : nonce @ alice
name k : enckey Name(n) @ alice
</code></pre>
<p>Here, <code>nonce</code> and <code>enckey Name(n)</code> are name types. Each name type is in one-to-one correspondence to  a keyed cryptographic primitives. More details are given <a href="./crypto.html">here</a>.</p>
<h3 id="exists-types"><a class="header" href="#exists-types">Exists Types</a></h3>
<h3 id="if-then-else-types"><a class="header" href="#if-then-else-types">If-then-else types</a></h3>
<p>If <code>p</code> is a <a href="#propositions">proposition</a>, and <code>t1</code> / <code>t2</code> are types, then <code>if p then t1 else t2</code> is a type. If Owl can prove that <code>p</code> holds (or doesn’t hold), then this type will automatically simplify to <code>t1</code> (respectively, <code>t2</code>).</p>
<p>If-then-else types are most useful for specifying the return types of procedures that depend on whether something is corrupted. For example:</p>
<pre><code class="language-owl">locality alice
locality bob

name n : nonce
name K : enckey Name(n)

def server (k : Name(K)) @ bob : if sec(K) then Option Name(n) else Option Data&lt;adv&gt; = 
    input i in 
    adec(k, i)
</code></pre>
<p>The return type of the server states that if the name <code>K</code> is a secret, we get a value of type <code>Option Name(n)</code> (i.e., a value which is either <code>None</code> or <code>Some(v)</code>, where <code>v = get(n)</code>); if <code>K</code> is corrupt, then we get <code>Option Data&lt;adv&gt;</code>. This is achieved using <a href="./aenc.html">authenticated encryption</a>.</p>
<h3 id="ghost"><a class="header" href="#ghost">Ghost</a></h3>
<p>It is often useful to add information to a data structure that only exists for proof purposes. An example of this is given below:</p>
<pre><code class="language-owl">
name eph : DH @ alice
name n : nonce @ alice 

struct stage2_t {
    recvd_eph_pk : Ghost,
    val : if recvd_eph == dhpk(get(eph)) then  Name(n) else Data&lt;adv&gt;
}
</code></pre>
<p>Here, we have a pair of two values: the first, which has no runtime representation, represents a received ephemeral public key.
The second has an <a href="#if-then-else-types">if-then-else type</a> which states that the <code>val</code> is equal to <code>get(n)</code> if the ephemeral key is the expected one, and arbitrary junk data otherwise.</p>
<h3 id="grammar-of-types"><a class="header" href="#grammar-of-types">Grammar of Types</a></h3>
<pre><code>t ::=  
    | Data&lt;L&gt;
    | Data&lt;L&gt; |aexpr| 
    | Data&lt;L, |L|&gt; // L : Label
    | Ghost
    | x:t{phi} // phi : Prop
    | Option t
    | s // where s is a struct or enum
    | if prop then t else t
    | Bool&lt;L&gt; // L : Label
    | Unit
    | Name(n) // n : Name
    | vk(n) // n : Name, n must have name type sigkey t for some t
    | dhpk(n) // n : Name, n must have name type DH
    | encpk(n) // n : Name, n must have name type pkekey t
    | shared_secret(n, m) // n, m : Name, must have name type DH
    | exists i. t // binds an index i in t
    | Const(HC) // HC is a hex constant, eg 0x1234
</code></pre>
<h2 id="localities"><a class="header" href="#localities">Localities</a></h2>
<p>Localities specify the parties of the protocol. Every compiled name declaration and <code>def</code> must be attached to a locality. Localities for a single party are declared simply as</p>
<pre><code class="language-owl">locality alice
</code></pre>
<p>while a <em>family</em> of localities (e.g., specifying a protocol between $n$ servers and clients) are specified with an <em>arity</em>, like so:</p>
<pre><code class="language-owl">locality Server : 1
locality Client : 1
</code></pre>
<p>Here, the <code>1</code> represents the number of <em>party IDs</em> the locality takes as input. For example, we may declare this:</p>
<pre><code class="language-owl">name n&lt;@j&gt; : nonce @ Server&lt;j&gt; 
</code></pre>
<p>to mean that each server stores a <em>single</em> name; while this:</p>
<pre><code class="language-owl">name n&lt;i@j&gt; : nonce @ Server&lt;j&gt;
</code></pre>
<p>means that each server <code>Server&lt;j&gt;</code> stores a family of names <code>n&lt;i,j&gt;</code>. Here, <code>i</code> is a <em>session ID</em>; party IDs and session IDs are detailed in <a href="#indices">indices</a>.</p>
<h2 id="indices"><a class="header" href="#indices">Indices</a></h2>
<p>To handle protocols with a polynomial number of parties, or a polynomial number of sessions for each party, Owl has a notion of an <em>index</em>. Indices can be thought of as type-level numbers (albeit ones that cannot be added, but just passed around). Indices come in three types: <em>party IDs</em>, which are used to index a collection of parties (e.g., the <code>i</code>th client); <em>session IDs</em>, which are used to index within a computation carried out by a single locality (e.g., the <code>i</code>th Diffie-Hellman computation done by a particular party); and <em>ghost indices</em>, which only have proof content.</p>
<p>We introduce indices during computations by having index arguments to <code>def</code>s:</p>
<pre><code class="language-owl">locality Server : 1
name n&lt;i@j&gt; : nonce @ Server&lt;j&gt;
def client_main&lt;i@j&gt;(x : Name(n&lt;i@j&gt;)) @ Server&lt;j&gt; : Unit = 
    let y = get(n&lt;i@j&gt;) in 
    assert (x == y);
    ()
</code></pre>
<p>First, we have a locality with an <em>arity</em> 1, meaning it takes one party ID.
Then, we have the indexed name <code>n&lt;i@j&gt;</code>, which takes a session ID <code>i</code> and a party ID <code>j</code>. (The <code>@</code> symbol separates session IDs from party IDs). Index arguments are then introduced after the method name during a <code>def</code>.</p>
<p>Structs and enums can also be indexed:</p>
<pre><code class="language-owl">locality Server : 1
name n&lt;i@j&gt; : nonce @ Server&lt;j&gt;

struct MyStruct&lt;i,j&gt; {
    v : Name(n&lt;i@j&gt;)
}

def client_main&lt;i@j&gt;(s : MyStruct&lt;session i,pid j&gt;) @ Server&lt;j&gt; : Unit = 
    ()
</code></pre>
<p>Due to a current design limitation, the syntax for indices is a bit different for structs and enums.<br>Indices are introduced into struct declarations without regard for their type (thus, we have <code>&lt;i,j&gt;</code> instead of <code>&lt;i@j&gt;</code>). When making reference to a struct type (e.g., for <code>MyStruct</code>), one must then annotate the index type (hence, we have <code>MyStruct&lt;session i, pid j&gt;</code>.)</p>
<h2 id="propositions"><a class="header" href="#propositions">Propositions</a></h2>
<p>A <em>proposition</em> is a proof-level property that may be true or false. Propositions in Owl are checked using an SMT solver. We can see them at work here:</p>
<pre><code class="language-owl">locality alice

def client(x : Data&lt;adv&gt; |2|, y : Data&lt;adv&gt; |2|, z : Data&lt;adv&gt; |2|, w : Data&lt;adv&gt; |2| ) @ alice : Unit = 
    assert (123 == 123);
    assert ((concat(x, y) == concat(z, w)) ==&gt; (x == z));
    ()
</code></pre>
<p>Assert statements carry propositions, and fail to type check if the SMT solver fails to prove that the proposition is always true. We can see in the second line that the SMT solver can be used to prove nontrivial facts, such as the fact that concatenation is injective (when appropriate side conditions on lengths hold).</p>
<p>Propositions can show up in <a href="#refinement-types">refinement types</a>, <a href="#if-then-else-types">if-then-else types</a>, <a href="#assertassume">assert/assume expressions</a>, and <a href="#case-splitting-on-a-proposition">pcase expressions</a>, among other places.</p>
<h3 id="predicates"><a class="header" href="#predicates">Predicates</a></h3>
<p>A predicate is a <a href="#propositions">proposition</a>-level macro. An example is below:</p>
<pre><code class="language-owl">locality alice

predicate ok(v) = 
    (v == 0x1234 \/ v == 0x2345)

def foo(x : (v:Data&lt;adv&gt;{ok[v]})) @ alice : Unit = 
    assert (x != 0x5555);
    ()
</code></pre>
<p>Predicates do not require type annotations on its arguments, since at the level of propositions, all values are bitstrings. Note that when we apply <code>ok</code>, we must use square brackets (such as <code>ok[v]</code>); this is a current limitation of the parser.</p>
<h3 id="grammar-2"><a class="header" href="#grammar-2">Grammar</a></h3>
<pre><code>p ::= // prop
    | True
    | False
    | corr(N) // N : Name. N is corrupt; same as [N] &lt;= adv
    | sec(N) // N : Name. N is secret; same as [N] !&lt;= adv
    | let x = a in p // a : atomic expr
    | a1 == a2 // a1, a2 : atomic expr
    | a1 != a2 // a1, a2 : atomic expr
    | i1 =idx i2 // i1, i2 : index
    | i1 !=idx i2 // i1, i2 : index
    | l1 &lt;= l2 // l1, l2 : label
    | l1 !&lt;= l2 // l1, l2 : label
    | happened(foo&lt;..&gt;(x, y, ..., z)) // foo is a method name; &lt;..&gt; are index parameters (optional); x, y, .., z are arguments (atomic exprs)
    | forall x : idx, y : idx, ..., z : idx. p // x, y, z are identifiers
    | forall x : bv, y : bv, ..., z : bv. p // x, y, z are identifiers
    | aad(N)[a] // N : Name, a : atomic expr
    | in_odh(a, b, c) // a, b, c : atomic expr
    | honest_pk_enc&lt;N&gt;(a) // N : Name, a : atomic expr
    | foo&lt;...&gt;[x, y, .., z] // foo is a predicate; &lt;..&gt; are index  parameters (optional); x, y, .., z are arguments (atomic exprs)
    | a // a : atomic expr. Implicit cast to (a == true)
</code></pre>
<h2 id="expressions"><a class="header" href="#expressions">Expressions</a></h2>
<p>Computations in Owl are carried out by <em>expressions</em>. Expressions are stratified into two levels: <a href="#atomic-expressions"><em>atomic expressions</em></a>, which represent pure computations; and <em>effectful expressions</em>. Note that in Owl, cryptographic operations are considered effectful.</p>
<h3 id="atomic-expressions"><a class="header" href="#atomic-expressions">Atomic Expressions</a></h3>
<p>Atomic expressions represent pure computations, and can thus arise up in type-level constructs such as <a href="#propositions">propositions</a>.</p>
<h4 id="length-constants"><a class="header" href="#length-constants">Length Constants</a></h4>
<p>When specifying (for example) data formats, it is important to know the length of an encryption key. For this purpose, Owl supports the syntax <code>|LC|</code>, where <code>LC</code> here is the name for a length constant. For example, type <code>Data&lt;adv&gt; | |nonce| |</code> is parsed as follows:</p>
<ul>
<li><code>Data&lt;adv&gt; | a |</code> is a type, whenever <code>a</code> is an atomic expression;</li>
<li><code>|nonce|</code> is an atomic expression, since <code>nonce</code> is the name for a length constant (which specifies the length of names of type <code>nonce</code>).</li>
</ul>
<p>The supported length constants currently are:</p>
<ul>
<li><code>nonce</code>; for the length of <code>get(N)</code> if <code>N : nonce</code>;</li>
<li><code>DH</code>, for the length of <code>get(N)</code> if <code>N : DH</code>. Note that this is a Diffie-Hellman <em>secret</em> (i.e., exponent), not a group element;</li>
<li><code>enckey</code>; for the length of <code>get(N)</code> if <code>N : enckey T</code>;</li>
<li><code>pke_sk</code>; for the length of <code>get(N)</code> if <code>N : pkekey T</code>;</li>
<li><code>sigkey</code>; for the length of <code>get(N)</code> if <code>N : sigkey T</code>;</li>
<li><code>kdfkey</code>; for the length of <code>get(N)</code> if <code>N</code> is a <a href="./hkdf.html">KDF key</a></li>
<li><code>mackey</code>; for the length of <code>get(N)</code> if <code>N : mackey T</code>;</li>
<li><code>signature</code>; for the length of the result of <a href="./signatures.html"><code>sign</code></a>;</li>
<li><code>pke_pk</code>; for the length of <code>enc_pk(x)</code> when <code>x</code> is a secret key for public-key encryption (i.e., has type <code>Name(N)</code> if <code>N : pkekey T</code>);</li>
<li><code>vk</code>; for the length of <code>vk(x)</code> when <code>x</code> is a signing key (i.e., has type <code>Name(N)</code> if <code>N : sigkey T</code>);</li>
<li><code>maclen</code>; for the length of a MAC computed by <a href="./mac.html"><code>mac</code></a></li>
<li><code>tag</code>; for the length of an enum tag (typically one byte);</li>
<li><code>counter</code>; for the length of a counter, used primarily by <a href="./aenc.html">authenticated encryption</a>;</li>
<li><code>crh</code>; for the length of a <a href="./crh.html">collision-resistant hash</a>;</li>
<li><code>group</code>; for the length of a <a href="./hkdf.html">group element</a>.</li>
</ul>
<h4 id="user-defined-functions"><a class="header" href="#user-defined-functions">User-defined functions</a></h4>
<p>In Owl, we can define <code>func</code>s, which are atomic expression-level macros. A mininal example is below:</p>
<pre><code class="language-owl">locality alice

func make_foo(x) = 
    x ++ 0x1234

def foo() @ alice : Unit =
    input i in
    output make_foo(i)
</code></pre>
<h4 id="grammar-3"><a class="header" href="#grammar-3">Grammar</a></h4>
<pre><code>a ::= // atomic expr
    | a * a // integer multiplication
    | a ++ a // concatenation
    | a1 &amp;&amp;&amp; a2 // if a1 : Lemma p1, and a2 : Lemma p2, then a1 &amp;&amp;&amp; a2 : Lemma (p1 /\ p2)
    | a1 &amp;&amp; a2 // Boolean conjunction
    | a1 + a2  // integer addition
    | !a // Boolean negation
    | () // unit
    | true
    | false 
    | "&lt;alphanum&gt;" // Strings
    | 0x&lt;hexConst&gt; // Hex const; e.g., 0x1234. 0x is the empty hex constant.
    | &lt;natural&gt;    // Integers; e.g., 67. 
    | | LC | // Length constants, where LC is a name of a length constant. 
    | gkdf&lt;nks; j&gt;(a, b, c) // KDF operation in Ghost. nks is a row of name kinds (separated by ||); j is an integer index into this row, and a, b, c are atomic exprs.
    | get(N) // obtain the value of a base name N.
    | get_encpk(N) // obtain the public key for N, if N : Name corresponds to a public encryption key.
    | get_vk(N) // obtain the verification key for N, if N : Name corresponds to a signing key.
    | f&lt;...&gt;(x, y, .., z) // apply function symbol f to arguments x, y, ..., z : atomic expr. Inside &lt;...&gt; are _function parameters_ (used mainly for index arguments to constructors for structs and enums).
    | x // x is a variable
</code></pre>
<h3 id="assertassume"><a class="header" href="#assertassume">Assert/assume</a></h3>
<h3 id="case-splitting-on-a-proposition"><a class="header" href="#case-splitting-on-a-proposition">Case-Splitting on a Proposition</a></h3>
<h3 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h3>
<h4 id="parsing-structs"><a class="header" href="#parsing-structs">Parsing Structs</a></h4>
<h4 id="case-analysis-on-enums"><a class="header" href="#case-analysis-on-enums">Case Analysis on Enums</a></h4>
<h3 id="debug-expressions"><a class="header" href="#debug-expressions">Debug Expressions</a></h3>
<h2 id="declarations"><a class="header" href="#declarations">Declarations</a></h2>
<p>Above, we have seen examples of declaring <a href="#labels">names</a>, methods via <code>def</code> (see <a href="#labels">here</a> and <a href="#indices">here</a>), <a href="#structs-enums-and-option-types">structs and enums</a>, and <a href="#localities">localities</a>. Below, we outline a number of additional top-level declarations used in Owl protocols.</p>
<h3 id="type-and-name-type-definitions"><a class="header" href="#type-and-name-type-definitions">Type and Name Type definitions</a></h3>
<p>One can give abbrevations for both types and name types:</p>
<pre><code class="language-owl">locality alice
locality bob

nametype my_nonce = nonce

name m : my_nonce @ alice 

type my_msg_t = Name(m)

def client(v : my_msg_t) @ alice : Unit = 
    assert (v == get(m));
    ()
</code></pre>
<p>Name type abbreviations may also carry index arguments:</p>
<pre><code class="language-owl">locality alice
name m&lt;i&gt; : nonce @ alice

nametype my_key&lt;i&gt; = enckey Name(m&lt;i&gt;)

name k&lt;i&gt; : my_key&lt;i&gt; @ alice

def client&lt;i&gt;(my_k : Name(k&lt;i&gt;)) @ alice : Unit = 
    let c = aenc(my_k, get(m&lt;i&gt;)) in
    ()
</code></pre>
<h3 id="corruption-declarations"><a class="header" href="#corruption-declarations">Corruption declarations</a></h3>
<p>It is often necessary to restrict the adversary model by asserting that certain names are known to the adversary by default. We do this with a <em>corruption declaration</em>, which is as follows:</p>
<pre><code class="language-owl">locality alice

name n : nonce @ alice
name m : nonce @ alice

corr [n] ==&gt; [m] // If n is corrupt, m is as well
</code></pre>
<p>All corruption declarations in Owl are hypothetical, and have the form <code>corr L1 ==&gt; L2</code>; this emits the axiom that if <code>L1 &lt;= adv</code>, then <code>L2 &lt;= adv</code>. One can add non-hypothetical corruption axioms by letting the left-hand side be <code>adv</code>:</p>
<pre><code class="language-owl">locality alice

name n : nonce @ alice
corr adv ==&gt; [n]
</code></pre>
<p>The above constructs a name <code>n</code> which Owl trusts is randomly generated, but readable by the adversary.</p>
<p>Corruption declarations can be indexed:</p>
<pre><code class="language-owl">locality alice

name n&lt;i&gt; : nonce @ alice 
name m&lt;i&gt; : nonce @ alice 

corr&lt;i&gt; [m&lt;i&gt;] ==&gt; [n&lt;i&gt;]
</code></pre>
<h3 id="odh-declarations"><a class="header" href="#odh-declarations">ODH Declarations</a></h3>
<p>To associate Diffie-Hellman shared secrets with hash permissions, one can use an ODH declaration. More detail is given <a href="./hkdf.html">here</a>.</p>
<h3 id="counter-declarations"><a class="header" href="#counter-declarations">Counter Declarations</a></h3>
<p>Owl has a notion of a monotonic counter, which is used primarily for authenticated encryption (but can be used for other purposes). An example is given below:</p>
<pre><code class="language-owl">locality alice

counter C @ alice

def foo() @ alice : Unit = 
    inc_counter C; // Increments the counter by one
    let x : (v:Data&lt;adv&gt;{length(v) == |counter|}) = get_counter C in 
    ()
</code></pre>
<p>Counters support two operations: <code>inc_counter</code>, which increments it by one; and <code>get_counter</code>, which returns the current value of the counter. Owl doesn’t currently model that the counter is monotonic, but the fact that we cannot reset or decrement the counter guarantees monotonicity.
More details are given <a href="./aenc.html">here</a>.</p>
<h3 id="predicate-declarations"><a class="header" href="#predicate-declarations">Predicate Declarations</a></h3>
<p>Details <a href="#predicates">here</a>.</p>
<h3 id="func-declarations"><a class="header" href="#func-declarations">Func Declarations</a></h3>
<p>Details <a href="#user-defined-functions">here</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="example.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="crypto.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="example.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="crypto.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>


        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-02b85ac0.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
